#include <iostream>
#include <fstream>
#include <cstring>
#include <windows.h>

#include "tga.hpp"
#include "font.hpp"
#include "offset.hpp"

using namespace std;


static uint8_t tga_pallete[] =
{
	0x00, 0x00, 0x00, 0x00, 0x5F, 0x5F, 0x5F, 0xFF, 0x7F, 0x7F, 0x7F, 0xFF, 0x9F, 0x9F, 0x9F, 0xFF,
	0xBF, 0xBF, 0xBF, 0xFF, 0xDF, 0xDF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
};

bool decodeToTga(int charId, const char* filename)
{
	int i, j, k;
	TGA_FILEHEADER tga;

	memset(&tga, 0, sizeof(TGA_FILEHEADER));

	tga.color_map_type = 1;
	tga.image_type = 1;
	tga.cm_length = sizeof(tga_pallete) / 4;
	tga.map_entry_size = 32;
	tga.pixel_depth = 8;
	tga.width = getCharWidth(charId);
	tga.height = getCharHeight();

	uint8_t* data = decodeChar(charId);

	if (data == NULL) {
		cout << "No data" << endl;
		return false;
	}

	ofstream file(filename, ofstream::binary);
	file.write((char*)&tga, sizeof(TGA_FILEHEADER));
	file.write((char*)&tga_pallete, sizeof(tga_pallete));

	for (i = getCharHeight() - 1; i > -1; i--) {
		for (j = 0; j < getCharWidth(charId); j++) {
			for (k = 0; k < 7; k++) {
				if (data[i * getCharWidth(charId) * 4 + j * 4] == sh_pallete[k]) {
					file.write((char*)&k, 1);
				}
			}
		}
	}

	file.close();

	return true;
}

bool encodeFromTga(int charId, const char* filename)
{
	bool ret = false;
	int encodedSize = 0;
	int i, j;
	uint8_t c;
	TGA_FILEHEADER tga;

	ifstream file(filename, ios::in | ios::binary | ios::ate);

	if (file.is_open()) {
		file.seekg(0, ios::beg);
		file.read((char*)&tga, sizeof(TGA_FILEHEADER));

		if (tga.color_map_type != 1 || tga.image_type != 1 ||
			tga.cm_length != sizeof(tga_pallete) / 4 || tga.map_entry_size != 32 ||
			tga.pixel_depth != 8) {
			cout << "Wrong tga format!" << endl;
			return false;
		}
#if 1		
		if (tga.height != getCharHeight()) {
			cout << "Wrong character height!" << endl;
			return false;
		}

		if (charId >= 0xE0 && tga.width != getCharWidth(charId)) {
			cout << "Wrong character width!" << endl;
			return false;
		}
#endif

		file.seekg(sizeof(TGA_FILEHEADER) + sizeof(tga_pallete), ios::beg);

		int size = tga.width * tga.height * 4;
		uint8_t* charData = new uint8_t[size];

		for (i = tga.height - 1; i > -1; i--) {
			for (j = 0; j < tga.width; j++) {
				file.read((char*)&c, 1);

				if (c == 0) {
					charData[i * tga.width * 4 + j * 4 + 0] = 0;
					charData[i * tga.width * 4 + j * 4 + 1] = 0;
					charData[i * tga.width * 4 + j * 4 + 2] = 0;
					charData[i * tga.width * 4 + j * 4 + 3] = 0;
				}
				else {
					charData[i * tga.width * 4 + j * 4 + 0] = sh_pallete[c];
					charData[i * tga.width * 4 + j * 4 + 1] = sh_pallete[c];
					charData[i * tga.width * 4 + j * 4 + 2] = sh_pallete[c];
					charData[i * tga.width * 4 + j * 4 + 3] = 0xFF;
				}
			}
		}

		file.close();

		if (charId < 0xE0) {
			setCharWidth(charId, (uint8_t)tga.width);
		}

		uint8_t *out = new uint8_t[size];
		encodedSize = encodeChar(charData, size, out);
		if (encodedSize > 0 && out != NULL) {
			ret = insertData(getFontData(), charId, out, encodedSize, getDataOffset(), getMaxId());
		}
		delete[] charData;
		delete[] out;
	}
	return ret;
}


bool createBitmap(char* filename, int sx, int sy)
{
	int i, w, h, x, y;
	TGA_FILEHEADER tga;

	cout << "Creating bitmap" << endl;

	//7580 is max for sh2
	if (sx * sy > getMaxId()) {
		cout << "Error: selected too many chars!" << endl;
		return false;
	}

	memset(&tga, 0, sizeof(TGA_FILEHEADER));

	tga.color_map_type = 0;
	tga.image_type = RGBA;
	tga.cm_length = 0;
	tga.map_entry_size = 0;
	tga.pixel_depth = 32;
	tga.image_desc = 8 | 1 << 5;
	tga.width = (getCharWidth(0xE0) + 2) * sx;
	tga.height = (getCharHeight() + 2) * sy;

	int size = tga.width * tga.height * 4;
	uint8_t* tex = new uint8_t[size + 2048];
	int allch = (tga.width * tga.height) / ((getCharHeight() + 2) * (getCharWidth(0xE0) + 2));

	memset(tex, 0, size);

	for (i = 0; i < allch; i++) {
		uint8_t* data = decodeChar(i);
		if (data != NULL) {
			y = ((i / sx)) * tga.width * 4 * (getCharHeight() + 2) + tga.width * 4;
			x = (i % sx) * (getCharWidth(0xE0) + 2) * 4 + 4;

			for (h = getCharHeight() - 1; h > -1; h--) {
				for (w = 0; w < getCharWidth(i); w++) {
					tex[x + y + tga.width * 4 * h + w * 4 + 0] = data[h * getCharWidth(i) * 4 + w * 4 + 0];
					tex[x + y + tga.width * 4 * h + w * 4 + 1] = data[h * getCharWidth(i) * 4 + w * 4 + 1];
					tex[x + y + tga.width * 4 * h + w * 4 + 2] = data[h * getCharWidth(i) * 4 + w * 4 + 2];
					tex[x + y + tga.width * 4 * h + w * 4 + 3] = data[h * getCharWidth(i) * 4 + w * 4 + 3];
				}
			}
			delete[] data;
		}
	}

	cout << "Createbitmap ok: " << i << " chars" << endl;

	ofstream file(filename, ofstream::binary);
	file.write((char*)&tga, sizeof(TGA_FILEHEADER));
	file.write((char*)tex, size);
	file.close();
	delete[] tex;

	char wdataname[255];
	memset(wdataname, 0, sizeof(wdataname));
	strncpy_s(wdataname, filename, strlen(filename) - 4);
	strcat_s(wdataname, "_fontwdata.bin");
	ofstream wfile(wdataname, ofstream::binary);
	if (wfile.is_open()) {
		wfile.write((char*)getFontData()->widthData, 0xE0);
		wfile.close();
	}

	return true;
}

bool writeBitmap(char* fontfilename, char* filename, int sx, int sy)
{
	bool ret = false;
	int i, k;
	TGA_FILEHEADER tga;

	ifstream file(filename, ios::in | ios::binary | ios::ate);

	if (file.is_open()) {
		file.seekg(0, ios::beg);
		file.read((char*)&tga, sizeof(TGA_FILEHEADER));

		if (tga.color_map_type != 0 || tga.image_type != RGBA ||
			tga.cm_length != 0 || tga.map_entry_size != 0 ||
			tga.pixel_depth != 32 || tga.image_desc != (8 | 1 << 5)) {
			cout << "Wrong tga format!" << endl;
			return false;
		}

		if (tga.width != (getCharWidth(0xE0) + 2) * sx) {
			cout << "Wrong character width!" << endl;
			return false;
		}

		if (tga.height != (getCharHeight() + 2) * sy) {
			cout << "Wrong character height!" << endl;
			return false;
		}

		char wdataname[255];
		memset(wdataname, 0, sizeof(wdataname));
		strncpy_s(wdataname, filename, strlen(filename) - 4);
		strcat_s(wdataname, "_fontwdata.bin");
		ifstream wfile(wdataname, ios::in | ios::binary | ios::ate);
		uint8_t* wdata = new uint8_t[0xE0 * 2];

		if (wfile.is_open()) {
			wfile.seekg(0, ios::beg);
			wfile.read((char*)wdata, 0xE0);
			wfile.close();
		}
		else {
			cout << "No '" << wdataname << "' present in directory!" << endl;
			file.close();
			return false;
		}

		file.seekg(sizeof(TGA_FILEHEADER), ios::beg);
		int size = tga.width * tga.height * 4;
		uint8_t* tex = new uint8_t[size];
		if (tex == NULL)
			return false;

		file.read((char*)tex, size);
		file.close();

		int allch = (tga.width * tga.height) / ((getCharHeight() + 2) * (getCharWidth(0xE0) + 2));
		int width, x, y, w, h;
		int zeropix;

		for (i = 0; i < allch; i++) {
			if (i < 0xE0) {
				width = wdata[i];
			}
			else {
				width = getCharWidth(0xE0);
			}

			if (width == 0) {
				if (i < 0xE0 && getCharWidth(i) != 0) {
					ret = insertData(getFontData(), i, NULL, 0, getDataOffset(), getMaxId());
					if (!ret) {
						cout << "\t Failed to insert char id: " << i << endl;
						break;
					}
				}
				continue;
			}

			zeropix = 0;
			int size = width * getCharHeight() * 4;

			uint8_t* data = new uint8_t[size];
			if (data != NULL) {
				y = ((i / sx)) * tga.width * 4 * (getCharHeight() + 2) + tga.width * 4;
				x = (i % sx) * (getCharWidth(0xE0) + 2) * 4 + 4;

				for (h = getCharHeight() - 1; h > -1; h--) {
					for (w = 0; w < width; w++) {
						data[h * width * 4 + w * 4 + 0] = tex[x + y + tga.width * 4 * h + w * 4 + 0];
						data[h * width * 4 + w * 4 + 1] = tex[x + y + tga.width * 4 * h + w * 4 + 1];
						data[h * width * 4 + w * 4 + 2] = tex[x + y + tga.width * 4 * h + w * 4 + 2];
						data[h * width * 4 + w * 4 + 3] = 0xFF; //tex[x + y + tga.width * 4 * h + w * 4 + 3];

						for (k = 0; k < 7; k++) {
							if (data[h * width * 4 + w * 4 + 0] == sh_pallete[k] ||
								data[h * width * 4 + w * 4 + 1] == sh_pallete[k] ||
								data[h * width * 4 + w * 4 + 2] == sh_pallete[k]) {
								data[h * width * 4 + w * 4 + 0] = data[h * width * 4 + w * 4 + 1] = data[h * width * 4 + w * 4 + 2] = sh_pallete[k];
								break;
							}
						}

						if (k == 7) {
							cout << "\tNeed to fix colour." << endl;
							int color = (data[h * width * 4 + w * 4 + 0] + data[h * width * 4 + w * 4 + 1] + data[h * width * 4 + w * 4 + 2]) / 3;
							for (k = 0; k < 7; k++) {
								if (color < sh_pallete[k])
									break;
							}
							if (k > 0)
								data[h * width * 4 + w * 4 + 0] = data[h * width * 4 + w * 4 + 1] = data[h * width * 4 + w * 4 + 2] = sh_pallete[k - 1];
							else
								data[h * width * 4 + w * 4 + 0] = data[h * width * 4 + w * 4 + 1] = data[h * width * 4 + w * 4 + 2] = 0;
						}

						if (data[h * width * 4 + w * 4 + 0] == 0) {
							zeropix++;
							data[h * width * 4 + w * 4 + 3] = 0x00;
						}
					}
				}
			}

			if (zeropix == getCharHeight() * width) {
				ret = insertData(getFontData(), i, NULL, 0, getDataOffset(), getMaxId());
			}
			else {
				uint8_t *out = new uint8_t[size];
				size = encodeChar(data, getCharHeight() * width * 4, out);
				if (size > 0) {
					if (i < 0xE0) {
						setCharWidth(i, width);
					}
					ret = insertData(getFontData(), i, out, size, getDataOffset(), getMaxId());
				}
			}

			delete[] data;
			if (!ret) {
				cout << "\t Failed to insert char id: " << i << endl;
				break;
			}
		}

		delete[] tex;

		if (ret) {
			cout << "Writebitmap ok: " << i << " chars" << endl;
		}
	}

	return ret;
}
